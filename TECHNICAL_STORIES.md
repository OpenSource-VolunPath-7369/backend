# Technical Stories - Volunpath Platform

## Technical Stories Implementadas

| Technical Story ID | Título                          | Descripción                                                                           | Criterios de Aceptación                                                                                     | Technical Epic ID | Estado |
| ------------------ | ------------------------------- | ------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ----------------- | ------ |
| TS01               | API de Autenticación            | Implementar endpoints REST para login (`POST /authentication/sign-in`), registro (`POST /authentication/sign-up`) y manejo de JWT para autenticación segura. El sistema genera tokens JWT con roles del usuario (ROLE_VOLUNTEER, ROLE_ORGANIZATION_ADMIN, ROLE_ADMIN) y los almacena en el frontend para autorización. | Dado que un usuario se registra o inicia sesión, cuando los datos son correctos (username único, email válido, password mínimo 6 caracteres), entonces recibe un JWT válido con sus roles y se redirige según su tipo (voluntario → /comunidad, organización → /dashboard). El token se incluye automáticamente en todas las peticiones subsiguientes mediante el header `Authorization: Bearer {token}`. | 1                 | ✅ Completado |
| TS02               | API de Voluntarios              | Exponer endpoints RESTful completos para gestión de voluntarios: `GET /volunteers`, `GET /volunteers/{id}`, `GET /volunteers/user/{userId}`, `POST /volunteers`, `PUT /volunteers/{id}`, `DELETE /volunteers/{id}`. Incluye control de acceso por token JWT y validación de datos (email, phone, avatar base64). | Dado que un voluntario es registrado o modificado, cuando el token JWT es válido y los datos cumplen las validaciones (email válido, avatar máximo 100KB en base64), entonces la operación se ejecuta correctamente y se refleja en la base de datos MySQL. El frontend puede crear, leer, actualizar y eliminar perfiles de voluntarios con persistencia completa. | 1                 | ✅ Completado |
| TS03               | API de Organizaciones           | Implementar endpoints RESTful completos para gestión de organizaciones: `GET /organizations`, `GET /organizations/{id}`, `GET /organizations/user/{userId}`, `POST /organizations`, `PUT /organizations/{id}`, `DELETE /organizations/{id}`. Incluye gestión de categorías, redes sociales, verificación y relación con usuarios mediante `userId`. | Dado que una organización es registrada o modificada, cuando el token JWT es válido y los datos cumplen las validaciones (name máximo 200 caracteres, description máximo 2000 caracteres, logo máximo 100KB en base64, email único), entonces la operación se ejecuta correctamente y se refleja en la base de datos. El frontend puede gestionar completamente el ciclo de vida de organizaciones. | 1                 | ✅ Completado |
| TS04               | API de Publicaciones            | Crear endpoints RESTful para gestión de publicaciones: `GET /publications`, `GET /publications/{id}`, `GET /publications/organization/{organizationId}`, `POST /publications`, `PUT /publications/{id}/like`, `DELETE /publications/{id}`. Incluye sistema de likes, estados (draft, published, archived) y asociación con organizaciones. | Dado que una organización crea o modifica una publicación, cuando el token JWT es válido y los datos son correctos (title requerido, status válido, image base64), entonces la publicación se guarda correctamente. Los voluntarios pueden dar like a publicaciones mediante `PUT /publications/{id}/like`, incrementando el contador de likes. Las publicaciones se pueden filtrar por organización y visualizar en el feed de comunidad. | 1                 | ✅ Completado |
| TS05               | API de Mensajes                 | Implementar endpoints RESTful para sistema de mensajería bidireccional: `GET /messages/user/{userId}`, `GET /messages/{id}`, `POST /messages`, `PUT /messages/{id}/read`, `DELETE /messages/{id}`. Incluye gestión de mensajes entre voluntarios y organizaciones, tipos de mensajes (volunteer_inquiry, activity_details, general, system) y marcado de mensajes como leídos. | Dado que un usuario envía un mensaje a otro usuario (voluntario u organización), cuando el token JWT es válido y el destinatario existe, entonces el mensaje se crea correctamente con senderId, recipientId, contenido, tipo y timestamp. El destinatario puede ver el mensaje en su lista, marcarlo como leído mediante `PUT /messages/{id}/read`, y responder. El sistema crea automáticamente una notificación para el destinatario cuando se envía un mensaje. | 1                 | ✅ Completado |
| TS06               | API de Notificaciones           | Crear endpoints RESTful para gestión de notificaciones: `GET /notifications/user/{userId}`, `GET /notifications/{id}`, `POST /notifications`, `PUT /notifications/{id}/read`, `PUT /notifications/user/{userId}/read-all`, `DELETE /notifications/{id}`. Incluye diferentes tipos de notificaciones (new_activity, new_message, activity_confirmed, activity_cancelled, general) y gestión de estado de lectura. | Dado que se crea una notificación para un usuario, cuando el token JWT es válido y los datos son correctos (title, message, type, actionUrl), entonces la notificación se guarda correctamente. Los usuarios pueden ver sus notificaciones, marcarlas individualmente como leídas o marcar todas como leídas mediante `PUT /notifications/user/{userId}/read-all`. El sistema crea notificaciones automáticamente cuando se envían mensajes, usando el userId correcto tanto para voluntarios como para organizaciones. | 1                 | ✅ Completado |
| TS07               | API de Usuarios                 | Exponer endpoints RESTful para consulta de usuarios: `GET /users`, `GET /users/{id}`. Permite obtener información de usuarios del sistema con sus roles asociados. | Dado que se solicita información de usuarios, cuando el token JWT es válido, entonces se retorna la lista de usuarios o un usuario específico con sus datos (id, username, email, name, avatar, roles). El endpoint permite al frontend obtener información de usuarios para funcionalidades como búsqueda de destinatarios en mensajería. | 1                 | ✅ Completado |
| TS08               | Seguridad del Token JWT         | Implementar generación, validación y expiración de tokens JWT con configuración de secret key y tiempo de expiración. Incluye inclusión automática de roles en el token y validación en cada petición mediante filtros de seguridad. | Dado que un usuario inicia sesión, cuando las credenciales son válidas, entonces se genera un token JWT con el username, email, roles y expiración configurada. El token se valida en cada petición mediante el header `Authorization: Bearer {token}`. Si el token es inválido o expirado, se retorna 401 Unauthorized. El frontend almacena el token en localStorage y lo incluye automáticamente en todas las peticiones mediante el servicio de API centralizado. | 1                 | ✅ Completado |
| TS09               | Configuración CORS               | Configurar Cross-Origin Resource Sharing (CORS) para permitir peticiones desde el frontend Angular en `http://localhost:4200`. Incluye configuración de métodos HTTP permitidos (GET, POST, PUT, DELETE, OPTIONS), headers permitidos (Authorization, Content-Type) y credenciales. | Dado que el frontend Angular realiza una petición al backend, cuando la petición proviene de `http://localhost:4200`, entonces el backend acepta la petición y retorna los headers CORS necesarios. Las peticiones con métodos GET, POST, PUT, DELETE funcionan correctamente sin errores de CORS. El header `Authorization` se permite y se procesa correctamente. | 1                 | ✅ Completado |
| TS10               | Persistencia con JPA/Hibernate  | Configurar Spring Data JPA con Hibernate para persistencia en base de datos MySQL. Incluye configuración de entidades, relaciones, validaciones con Jakarta Validation, auditoría automática (createdAt, updatedAt) y generación automática de esquema (ddl-auto=update). | Dado que se crea o modifica una entidad (User, Volunteer, Organization, Publication, Message, Notification), cuando los datos cumplen las validaciones (@NotBlank, @Email, @Size), entonces se persiste correctamente en la base de datos MySQL. Las relaciones entre entidades (User-Volunteer, User-Organization, Organization-Publication) se mantienen correctamente. Los campos de auditoría (createdAt, updatedAt) se actualizan automáticamente mediante `@EnableJpaAuditing`. | 1                 | ✅ Completado |
| TS11               | Validación de Datos              | Implementar validación de datos en todas las entidades y DTOs usando Jakarta Validation. Incluye validaciones de tamaño (avatar, logo, image máximo 100KB en base64 almacenados como LONGTEXT), formato (email), requeridos (@NotBlank) y valores permitidos (enums para status, type). | Dado que se envía una petición con datos inválidos, cuando los datos no cumplen las validaciones (email inválido, campo requerido vacío, imagen demasiado grande), entonces el backend retorna 400 Bad Request con mensajes de error descriptivos. Las validaciones se aplican tanto en las entidades JPA como en los DTOs de entrada (Resources). El frontend también valida los datos antes de enviarlos para mejorar la experiencia de usuario. | 1                 | ✅ Completado |
| TS12               | Documentación OpenAPI/Swagger   | Configurar SpringDoc OpenAPI para generar documentación interactiva de la API. Incluye anotaciones @Operation y @Tag en todos los controladores, visualización de esquemas de request/response, y acceso mediante `http://localhost:8080/swagger-ui.html`. | Dado que se accede a `http://localhost:8080/swagger-ui.html`, cuando el servidor está ejecutándose, entonces se muestra la documentación interactiva de todos los endpoints. Los desarrolladores pueden ver los esquemas de request/response, probar los endpoints directamente desde el navegador, y validar los modelos de datos. Todos los endpoints están documentados con descripciones, parámetros y ejemplos. | 3                 | ✅ Completado |
| TS13               | Mapeo de Roles Backend-Frontend | Implementar mapeo de roles del backend (ROLE_VOLUNTEER, ROLE_ORGANIZATION_ADMIN, ROLE_ADMIN) a roles del frontend (volunteer, organization, admin) para redirección correcta después del login. | Dado que un usuario inicia sesión, cuando el backend retorna roles en formato `ROLE_VOLUNTEER` o `ROLE_ORGANIZATION_ADMIN`, entonces el frontend mapea estos roles a `volunteer` u `organization` respectivamente y redirige al usuario a la página correcta (/comunidad para voluntarios, /dashboard para organizaciones). El sistema no permite que un usuario registrado como voluntario ingrese como organización y viceversa, ya que el rol se determina automáticamente desde las credenciales. | 1                 | ✅ Completado |
| TS14               | Gestión de Imágenes Base64      | Implementar almacenamiento de imágenes (avatars, logos, imágenes de publicaciones) en formato base64 en campos LONGTEXT de MySQL. Incluye validación de tamaño máximo (100KB), conversión en el frontend, y decodificación para visualización. | Dado que un usuario carga una imagen (avatar, logo o imagen de publicación), cuando la imagen es válida (formato correcto, tamaño máximo 100KB), entonces se convierte a base64 en el frontend, se envía al backend, y se almacena correctamente en la base de datos como LONGTEXT. Las imágenes se pueden recuperar y visualizar correctamente en el frontend mediante el prefijo `data:image/png;base64,` o similar. | 1                 | ✅ Completado |
| TS15               | Integración Frontend-Backend    | Conectar el frontend Angular con el backend Spring Boot mediante servicios REST. Incluye servicio centralizado de API (`ApiService`), inclusión automática de tokens JWT, manejo de errores HTTP, y mapeo de datos entre modelos del frontend y DTOs del backend. | Dado que el frontend realiza una petición al backend, cuando el servicio de API se utiliza correctamente, entonces la petición se envía a `http://localhost:8080/api/v1` con el token JWT en el header `Authorization: Bearer {token}`. Los datos se mapean correctamente entre los modelos del frontend (Volunteer, Organization, Publication, Message, Notification) y los DTOs del backend (Resources). Los errores HTTP se manejan correctamente y se muestran mensajes de error al usuario. | 1                 | ✅ Completado |

## Technical Stories Pendientes o Futuras

| Technical Story ID | Título                          | Descripción                                                                           | Criterios de Aceptación                                                                                     | Technical Epic ID | Estado |
| ------------------ | ------------------------------- | ------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ----------------- | ------ |
| TS16               | API de Reportes                 | Generar reportes vía API, exportables a JSON o PDF. Incluir reportes de actividad de usuarios, estadísticas de publicaciones, y métricas de participación. | Dado que un administrador solicita un reporte, cuando existen datos en el sistema, entonces se genera un reporte con la información solicitada y se puede exportar en formato JSON o PDF. Los reportes incluyen estadísticas de voluntarios, organizaciones, publicaciones, mensajes y notificaciones. | 2                 | ⏳ Pendiente |
| TS17               | Auditoría de Acciones           | Registrar logs de todas las modificaciones en el sistema (creación, actualización, eliminación de entidades). Incluir información de usuario, timestamp, tipo de operación y datos modificados. | Dado que un usuario realiza cambios en el sistema (crear, actualizar, eliminar), cuando se completa la acción, entonces se registra un log con detalle de la operación (usuario, entidad, acción, timestamp, datos anteriores y nuevos). Los logs se almacenan en una tabla de auditoría y se pueden consultar mediante endpoints REST. | 2                 | ⏳ Pendiente |
| TS18               | Copias de Seguridad             | Configurar backups automáticos periódicos de la base de datos MySQL. Incluir programación de backups diarios, almacenamiento en ubicación segura, y restauración de backups. | Dado que se configura un backup automático, cuando ocurre el horario programado (por ejemplo, diario a las 2:00 AM), entonces se genera una copia automática de la base de datos MySQL y se almacena en una ubicación segura (servidor de archivos o almacenamiento en la nube). El sistema registra el éxito o fallo de cada backup. | 3                 | ⏳ Pendiente |
| TS19               | Exportar Logs                   | Permitir exportación de registros del sistema (logs de auditoría) en formatos CSV o PDF. Incluir filtros por fecha, usuario, tipo de operación. | Dado que un administrador solicita exportar logs, cuando los logs existen en el sistema, entonces se generan archivos en formato CSV o PDF con los registros filtrados según los criterios especificados (rango de fechas, usuario, tipo de operación). Los archivos se pueden descargar mediante un endpoint REST. | 3                 | ⏳ Pendiente |
| TS20               | Pruebas Unitarias y Performance | Ejecutar pruebas automáticas (JUnit) para todos los servicios y controladores, y optimizar tiempos de respuesta del backend mediante índices en base de datos y caché. | Dado que se ejecutan pruebas unitarias, cuando todas las pruebas pasan (cobertura mínima del 80%), entonces se valida la integridad del sistema. Las pruebas incluyen servicios de dominio, servicios de aplicación, y controladores REST. El tiempo de respuesta de los endpoints principales es menor a 200ms para operaciones GET y menor a 500ms para operaciones POST/PUT. | 3                 | ⏳ Pendiente |
| TS21               | Control de Versiones API        | Implementar versionado de la API (v1, v2, etc.) y mantener documentación actualizada. Incluir estrategia de deprecación de endpoints antiguos. | Dado que se documenta un endpoint, cuando se hace un cambio que rompe compatibilidad, entonces se crea una nueva versión de la API (v2) y se mantiene la versión anterior (v1) durante un período de transición. La documentación OpenAPI se actualiza automáticamente y se incluyen notas de deprecación para endpoints antiguos. | 3                 | ⏳ Pendiente |
| TS22               | Sistema de Búsqueda Avanzada    | Implementar búsqueda full-text en publicaciones, mensajes y usuarios. Incluir filtros por categorías, fechas, y ordenamiento por relevancia o fecha. | Dado que un usuario realiza una búsqueda, cuando se ingresan términos de búsqueda, entonces se retornan resultados relevantes de publicaciones, mensajes o usuarios que coincidan con los términos. Los resultados se pueden filtrar por categorías, rango de fechas, y ordenar por relevancia o fecha. La búsqueda utiliza índices full-text de MySQL para optimizar el rendimiento. | 2                 | ⏳ Pendiente |
| TS23               | Notificaciones en Tiempo Real   | Implementar notificaciones push en tiempo real usando WebSockets o Server-Sent Events (SSE). Incluir notificaciones cuando se reciben mensajes, se publican nuevas actividades, o se confirman participaciones. | Dado que un usuario recibe un mensaje o se publica una nueva actividad, cuando el usuario está conectado, entonces recibe una notificación en tiempo real sin necesidad de refrescar la página. El sistema utiliza WebSockets o SSE para mantener una conexión persistente entre el frontend y el backend, y envía notificaciones automáticamente cuando ocurren eventos relevantes. | 2                 | ⏳ Pendiente |
| TS24               | Sistema de Filtros y Paginación | Implementar paginación en todos los endpoints que retornan listas (voluntarios, organizaciones, publicaciones, mensajes, notificaciones). Incluir filtros por criterios específicos y ordenamiento. | Dado que se solicita una lista de recursos, cuando se especifican parámetros de paginación (page, size) y filtros opcionales, entonces se retorna una página de resultados con metadatos de paginación (total de elementos, página actual, total de páginas). Los resultados se pueden ordenar por diferentes campos (fecha, nombre, etc.) y filtrar por criterios específicos (categorías, estado, etc.). | 2                 | ⏳ Pendiente |

---

## Resumen

- **Technical Stories Completadas:** 15
- **Technical Stories Pendientes:** 9
- **Total de Technical Stories:** 24

### Distribución por Epic:
- **Epic 1 (Funcionalidades Core):** 15 completadas
- **Epic 2 (Funcionalidades Avanzadas):** 4 pendientes
- **Epic 3 (Infraestructura y Calidad):** 5 pendientes

